<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>前端进阶技术 | 自习室</title><meta name="author" content="lhr"><meta name="copyright" content="lhr"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前端进阶技术       异步与同步概念&amp;emsp;&amp;emsp;前端的异步与同步是指在执行代码时，特定操作是按照顺序执行还是同时执行的不同方式。   &amp;emsp;&amp;emsp;异步（Asynchronous）是指代码的执行不会阻塞其他代码的执行，操作将在后台进行，并在完成后通过回调函数、Promise等方式返回结果。这种方式适用于涉及网络请求、文件读写、定时器等耗时操作，以避免造成页面卡顿或停滞。">
<meta property="og:type" content="article">
<meta property="og:title" content="前端进阶技术">
<meta property="og:url" content="https://l-204.github.io/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF/934f1248.html">
<meta property="og:site_name" content="自习室">
<meta property="og:description" content="前端进阶技术       异步与同步概念&amp;emsp;&amp;emsp;前端的异步与同步是指在执行代码时，特定操作是按照顺序执行还是同时执行的不同方式。   &amp;emsp;&amp;emsp;异步（Asynchronous）是指代码的执行不会阻塞其他代码的执行，操作将在后台进行，并在完成后通过回调函数、Promise等方式返回结果。这种方式适用于涉及网络请求、文件读写、定时器等耗时操作，以避免造成页面卡顿或停滞。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://l-204.github.io/imgs/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF/background.png">
<meta property="article:published_time" content="2023-10-12T14:33:34.000Z">
<meta property="article:modified_time" content="2023-10-27T07:07:40.031Z">
<meta property="article:author" content="lhr">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://l-204.github.io/imgs/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF/background.png"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="https://l-204.github.io/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF/934f1248.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端进阶技术',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-27 15:07:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/videos/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page child" href="/images/"><i class="fa-fw fas fa-image"></i><span> 图片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../imgs/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF/background.png')"><nav id="nav"><span id="blog-info"><a href="/" title="自习室"><span class="site-name">自习室</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/videos/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page child" href="/images/"><i class="fa-fw fas fa-image"></i><span> 图片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端进阶技术</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-12T14:33:34.000Z" title="发表于 2023-10-12 22:33:34">2023-10-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-27T07:07:40.031Z" title="更新于 2023-10-27 15:07:40">2023-10-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端进阶技术"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p style="font-size:48px;color=#fff">前端进阶技术</p>

</br>

</br>

<p><img src="/../imgs/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5.png" alt="异步与同步"></p>
<h1 id="异步与同步"><a href="#异步与同步" class="headerlink" title="异步与同步"></a>异步与同步</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;前端的异步与同步是指在执行代码时，特定操作是按照顺序执行还是同时执行的不同方式。</p>
</br>

<p>&emsp;&emsp;异步（Asynchronous）是指代码的执行不会阻塞其他代码的执行，操作将在后台进行，并在完成后通过回调函数、Promise等方式返回结果。这种方式适用于涉及网络请求、文件读写、定时器等耗时操作，以避免造成页面卡顿或停滞。</p>
</br>

<p>&emsp;&emsp;同步（Synchronous）是指代码的执行按照顺序依次进行，每个操作必须在前一个操作完成之后才能继续执行。同步操作会阻塞其他代码的执行，直到当前操作完成才能继续执行后续代码。</p>
</br>

<h2 id="常见的异步操作"><a href="#常见的异步操作" class="headerlink" title="常见的异步操作"></a>常见的异步操作</h2><p>&emsp;&emsp;在前端开发中，常见的异步操作包括：</p>
<ol>
<li>发起网络请求：例如使用Ajax或Fetch API向服务器发送请求获取数据，异步地等待服务器响应。</li>
<li>定时器：例如使用setTimeout或setInterval函数，在指定的时间后执行相应的操作。</li>
<li>事件处理：例如点击按钮时触发的事件处理函数，可以异步地执行一些操作。</li>
</ol>
</br>

<p>&emsp;&emsp;异步操作的优势在于能够提升用户体验和页面性能。通过异步执行，可以避免阻塞页面渲染和用户交互，减少页面卡顿现象，同时能够更好地处理耗时的操作，例如网络请求和数据处理。</p>
</br>

<p>&emsp;&emsp;然而，异步执行也需要注意处理异步操作的顺序和依赖关系，以避免出现意外结果或竞态条件。合理使用回调函数、Promise、async&#x2F;await等机制可以简化异步代码的编写和管理，提高代码的可读性和维护性。</p>
</br>

<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2></br>

<p>&emsp;<label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">执行顺序</label></p>
<p>&emsp;&emsp;同步：代码按照顺序一行一行地执行，每个操作必须在前一个操作完成之后才能继续执行。</p>
<p>&emsp;&emsp;异步：代码不按照顺序执行，某些操作会在后台执行，而程序会继续执行下面的代码。</p>
</br>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;中间&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 开始</span></span><br><span class="line"><span class="comment">// 中间</span></span><br><span class="line"><span class="comment">// 结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;定时器回调&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 开始</span></span><br><span class="line"><span class="comment">// 结束</span></span><br><span class="line"><span class="comment">// 定时器回调（2秒后输出）</span></span><br></pre></td></tr></table></figure>

</br>

<p>&emsp;<label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">阻塞效应</label></p>
<p>&emsp;&emsp;同步：代码的执行会阻塞后续的操作，直到当前操作完成。</p>
<p>&emsp;&emsp;异步：代码的执行不会阻塞后续的操作，后续操作会继续执行，无需等待当前操作完成。</p>
</br>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步阻塞示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 模拟耗时操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 开始</span></span><br><span class="line"><span class="comment">// 结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步非阻塞示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;定时器回调&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 开始</span></span><br><span class="line"><span class="comment">// 结束</span></span><br><span class="line"><span class="comment">// 定时器回调（下一个事件循环输出）</span></span><br></pre></td></tr></table></figure>

</br>

<p>&emsp;<label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">回调机制</label></p>
<p>&emsp;&emsp;同步：没有回调机制，代码的执行是顺序进行的。</p>
<p>&emsp;&emsp;异步：通常会使用回调函数来处理异步操作的结果或执行相应的操作。</p>
</br>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">syncFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;同步函数&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">syncFunction</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 开始</span></span><br><span class="line"><span class="comment">// 同步函数</span></span><br><span class="line"><span class="comment">// 42</span></span><br><span class="line"><span class="comment">// 结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncFunction</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;异步函数&quot;</span>);</span><br><span class="line">    <span class="title function_">callback</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"><span class="title function_">asyncFunction</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 开始</span></span><br><span class="line"><span class="comment">// 结束</span></span><br><span class="line"><span class="comment">// 异步函数（2秒后输出）</span></span><br><span class="line"><span class="comment">// 42（异步函数回调输出）</span></span><br></pre></td></tr></table></figure>

</br>

<p><img src="/../imgs/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1.png" alt="回调函数与回调地狱"></p>
<h1 id="回调函数与回调地狱"><a href="#回调函数与回调地狱" class="headerlink" title="回调函数与回调地狱"></a>回调函数与回调地狱</h1><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2></br>

<p>&emsp;&emsp;回调函数是指通过将一个函数作为参数传递给另一个函数，并在特定事件发生或条件满足时被调用执行的函数。</p>
</br>

<p>&emsp;&emsp;回调函数主要用于以下情况：</p>
</br>

<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">异步操作</label></li>
</ul>
<p>&emsp;&emsp;当需要进行耗时的操作，比如网络请求、文件读取等时，可以使用回调函数来处理异步操作的结果。例如，在JavaScript中，可以将回调函数传递给<code>setTimeout</code>函数，在指定的时间后执行回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是一个回调函数&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

</br>

<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">事件处理</label></li>
</ul>
<p>&emsp;&emsp;在事件驱动的编程中，可以使用回调函数来处理特定事件的逻辑。例如，在图形用户界面（GUI）应用程序中，可以将回调函数注册到按钮点击事件上，在按钮被点击时执行相应的逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.on_click(callback_function)</span><br></pre></td></tr></table></figure>

</br>

<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">定制行为</label></li>
</ul>
<p>&emsp;&emsp;通过将回调函数作为参数传递给其他函数，可以实现根据需求定制函数的行为。例如，在排序算法中，可以传递一个比较函数作为回调函数，来决定元素之间的比较规则。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">numbers.sort(callback_function)</span><br></pre></td></tr></table></figure>

</br>

<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">回调地狱</label></li>
</ul>
<p>&emsp;&emsp;当有多个异步操作需要按特定顺序执行时，也会使用回调函数。每个异步操作的回调函数中包含下一个异步操作的调用，形成了回调地狱的结构。例如，在Node.js中进行数据库查询操作时，可以使用回调函数来处理查询结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(<span class="string">&#x27;SELECT * FROM users WHERE role=&quot;admin&quot;&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, result</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">processQueryResult</span>(result, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</br>

<p>&emsp;&emsp;总的来说，回调函数在处理异步操作、事件驱动、定制化行为等场景下非常有用。它允许我们在特定事件发生时执行自定义逻辑，提高代码的灵活性和可扩展性。</p>
</br>

</br>

<h2 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h2></br>

<p>&emsp;&emsp;回调地狱是指在多个异步操作依赖于之前异步操作的结果时，嵌套过多的回调函数导致代码难以理解和维护的情况。为了解决回调地狱问题，可以采用以下方法：</p>
</br>

<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">使用Promise对象</label></li>
</ul>
<p>&emsp;&emsp;Promise是一种用于管理异步操作的对象，它提供了更简洁的处理异步操作的方式。通过使用Promise，可以将回调函数转换为链式的Promise调用，减少回调函数的嵌套。例如，在JavaScript中，可以使用<code>then</code>方法和<code>catch</code>方法来处理异步操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(<span class="string">&#x27;SELECT * FROM users WHERE role=&quot;admin&quot;&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">processQueryResult</span>(result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

</br>

<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">使用Async&#x2F;Await</label></li>
</ul>
<p>&emsp;&emsp;Async&#x2F;Await是ES2017引入的语法糖，用于更方便地处理异步操作。它基于Promise，并使用<code>async</code>和<code>await</code>关键字来编写更直观、可读性更高的异步代码。通过使用Async&#x2F;Await，可以避免大量的回调函数嵌套。例如，在JavaScript中，可以使用<code>await</code>关键字在异步函数中等待一个Promise的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">processQuery</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> db.<span class="title function_">query</span>(<span class="string">&#x27;SELECT * FROM users WHERE role=&quot;admin&quot;&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">processQueryResult</span>(result);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">processQuery</span>();</span><br></pre></td></tr></table></figure>

</br>

<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">使用异步库或框架</label></li>
</ul>
<p>&emsp;&emsp;有些语言、框架或第三方库提供了专门处理异步操作的工具，它们可以帮助简化和优化代码。例如，在Node.js中，可以使用异步流程控制库如<code>async</code>、<code>bluebird</code>等来处理复杂的异步操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.<span class="title function_">waterfall</span>([</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    db.<span class="title function_">query</span>(<span class="string">&#x27;SELECT * FROM users WHERE role=&quot;admin&quot;&#x27;</span>, callback);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">result, callback</span>) &#123;</span><br><span class="line">    <span class="title function_">processQueryResult</span>(result, callback);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">result, callback</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">], <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</br>

<p>&emsp;&emsp;通过上述方法，可以有效地减少回调地狱的问题，使代码更加可读、易于维护，并提高开发效率。选择适合你编程语言和框架的方式来处理回调地狱，根据实际情况选择最佳的解决方案。</p>
</br>

<p><img src="/../imgs/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%8F%92%E5%80%BC%E8%AF%AD%E6%B3%95.png" alt="解构赋值与插值语法"></p>
<h1 id="解构赋值与插值语法"><a href="#解构赋值与插值语法" class="headerlink" title="解构赋值与插值语法"></a>解构赋值与插值语法</h1><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>&emsp;&emsp;解构赋值是一种用于从数组或对象中提取数据并将其赋值给变量的语法。它通过模式匹配的方式，按照特定的规则将值解构成独立的变量。解构赋值可以用于提取数组中的元素、对象中的属性，并支持嵌套和默认值等功能。它的主要作用是方便地获取和操作复杂的数据结构中的数据。</p>
</br>

<p>&emsp;&emsp;在ES6之前，如果需要从多个层次嵌套的对象或数组中提取数据，通常需要写很多重复的代码，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从对象中提取数据</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">address</span>: &#123;</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;Beijing&#x27;</span>,</span><br><span class="line">    <span class="attr">street</span>: <span class="string">&#x27;Dongcheng Road&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = person.<span class="property">name</span>;</span><br><span class="line"><span class="keyword">const</span> age = person.<span class="property">age</span>;</span><br><span class="line"><span class="keyword">const</span> city = person.<span class="property">address</span>.<span class="property">city</span>;</span><br><span class="line"><span class="keyword">const</span> street = person.<span class="property">address</span>.<span class="property">street</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, age, city, street);  <span class="comment">// 输出：Alice 25 Beijing Dongcheng Road</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在上面的例子中，我们需要使用多个赋值语句来提取<code>person</code>对象中的<code>name</code>、<code>age</code>、<code>city</code>和<code>street</code>属性，代码显得冗长和重复。</p>
</br>

<p>&emsp;&emsp;使用解构赋值可以更好地处理这种情况，将提取数据和赋值合并到一个语句中，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用解构赋值从对象中提取数据</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, age, <span class="attr">address</span>: &#123; city, street &#125; &#125; = person;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, age, city, street);  <span class="comment">// 输出：Alice 25 Beijing Dongcheng Road</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在上面的例子中，我们使用了解构赋值从<code>person</code>对象中提取了<code>name</code>、<code>age</code>、<code>city</code>和<code>street</code>属性，并将它们赋值给相应的变量。解构赋值的语法使用了花括号（{}）来标识需要提取的属性，其中冒号（:）可以用于指定新的变量名。</p>
</br>

<p>&emsp;&emsp;除了从对象中提取数据，解构赋值还可以从数组中提取数据，并且可以同时从多个对象或数组中提取数据，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用解构赋值从数组中提取数据</span></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, second, ...rest] = numbers;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first, second, rest);  <span class="comment">// 输出：1 2 [3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在上面的例子中，我们使用了解构赋值从数组中提取了前两个元素，并将剩余的元素赋值给<code>rest</code>数组。使用省略号（…）可以获取剩余的元素并将它们放在一个新的数组中。</p>
</br>

<p>&emsp;&emsp;总之，解构赋值是一种方便的语法，可以在JavaScript中从数组或对象中提取数据并将其赋值给变量。使用解构赋值可以更好地处理复杂的数据结构，使代码更加简洁和易读。</p>
</br>

<h2 id="插值语法"><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h2><p>&emsp;&emsp;插值语法（或称为模板字符串）是一种用于动态生成字符串的语法。它允许在字符串中嵌入表达式或变量，并在最终生成的字符串中进行替换。插值语法可以提高字符串拼接的简洁性和可读性。</p>
</br>

<p>&emsp;&emsp;在不同的编程语言和框架中，插值语法的具体语法和使用方式可能会有所不同。</p>
</br>

<p>&emsp;&emsp;在JavaScript中，常见的插值语法是使用模板字符串（template literal）。模板字符串用反引号（<code>）包裹，并且可以在字符串中通过</code>${}&#96;的形式嵌入变量或表达式。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Alice&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用插值语法</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">`My name is <span class="subst">$&#123;name&#125;</span> and I&#x27;m <span class="subst">$&#123;age&#125;</span> years old.`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message);  <span class="comment">// 输出：My name is Alice and I&#x27;m 25 years old.</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在上面的例子中，我们使用了插值语法<code>$&#123;&#125;</code>来在模板字符串中嵌入变量<code>name</code>和<code>age</code>。当模板字符串被解析时，<code>$&#123;&#125;</code>中的表达式会被计算并替换为相应的值，最终生成最终的字符串。</p>
</br>

<p>&emsp;&emsp;插值语法不仅限于变量的嵌入，还可以包含任意的JavaScript表达式。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用插值语法嵌入表达式</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="string">`The sum of <span class="subst">$&#123;x&#125;</span> and <span class="subst">$&#123;y&#125;</span> is <span class="subst">$&#123;x + y&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);  <span class="comment">// 输出：The sum of 10 and 5 is 15</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在这个例子中，我们使用插值语法将表达式<code>$&#123;x + y&#125;</code>嵌入到模板字符串中，计算出变量<code>x</code>和<code>y</code>的和，并生成最终的字符串。</p>
</br>

<p>&emsp;&emsp;总之，插值语法是一种方便的字符串拼接方式，它使用特定的语法将变量或表达式嵌入到字符串中，使代码更易读、简洁和灵活。在不同的编程语言和框架中，插值语法的具体语法和用法可能会有所不同。</p>
</br>

<h2 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h2><ul>
<li><p><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">用途</label></p>
<ul>
<li><p>解构赋值用于从数组或对象中提取元素或属性并赋值给变量，方便操作数据</p>
</li>
<li><p>插值语法用于在字符串中嵌入表达式或变量，方便构建复杂的字符串</p>
</li>
</ul>
</li>
<li><p><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">符号</label></p>
<ul>
<li><p>解构赋值使用方括号 <code>[]</code> 或花括号 <code>&#123;&#125;</code> 进行解构</p>
</li>
<li><p>插值语法使用反引号 &#96;&#96; 进行字符串的声明</p>
</li>
</ul>
</li>
<li><p><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">适用范围</label></p>
<ul>
<li><p>解构赋值适用于任意复杂度的数据类型，并可以进行嵌套解构</p>
</li>
<li><p>插值语法适用于字符串构建，能够进行简单的表达式求值</p>
</li>
</ul>
</li>
</ul>
</br>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></br>

<ul>
<li><p><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">解构赋值</label></p>
<ul>
<li><p>用于将数组或对象中的元素或属性解构出来赋值给变量</p>
</li>
<li><p>适用于提取数据并赋值给变量</p>
</li>
<li><p>使用方括号 <code>[]</code> 或花括号 <code>&#123;&#125;</code></p>
</li>
<li><p>可以实现嵌套解构，提取更复杂的数据结构</p>
</li>
</ul>
</li>
</ul>
</br>

<ul>
<li><p><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">插值语法</label></p>
<ul>
<li><p>在字符串中嵌入变量或表达式</p>
</li>
<li><p>适用于构建字符串</p>
</li>
<li><p>使用反引号 &#96;&#96;</p>
</li>
<li><p>简单地在字符串中嵌入表达式</p>
</li>
</ul>
</li>
</ul>
</br>

<p><img src="/../imgs/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF/%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%8F%8D%E5%BA%94%E6%80%A7%E7%BC%96%E7%A8%8B.png" alt="命令式编程与反应性编程"></p>
<h1 id="命令式编程与反应性编程"><a href="#命令式编程与反应性编程" class="headerlink" title="命令式编程与反应性编程"></a>命令式编程与反应性编程</h1><h2 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h2><p>&emsp;&emsp;命令式编程（Imperative Programming）是一种编程范式，它通过明确地指定计算机要执行的操作步骤来描述程序的控制流程。在命令式编程中，程序员需要按照顺序编写代码，显式地指定每一步的执行过程和控制逻辑。常见的命令式编程语言包括C、Java、Python等。</p>
</br>

<h2 id="反应性编程"><a href="#反应性编程" class="headerlink" title="反应性编程"></a>反应性编程</h2><p>&emsp;&emsp;反应性编程（Reactive Programming）是一种编程范式，它关注数据流和变化传播。在反应性编程中，程序被建模为一组组件，这些组件之间通过定义数据流和数据依赖关系来相互交互。当数据流中的某个值发生变化时，该变化会自动传播到受影响的组件，触发相应的操作或更新。反应性编程对异步和事件驱动的处理具有很好的支持，能够更好地应对实时性要求高的系统。</p>
</br>

<h2 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h2><h3 id="命令式编程-1"><a href="#命令式编程-1" class="headerlink" title="命令式编程"></a>命令式编程</h3><p>&emsp;&emsp;当使用命令式编程时，程序员需要明确地指定代码的执行顺序和操作步骤，例如以下JavaScript代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令式编程示例</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在上述代码中，我们使用了for循环来遍历arr数组中的元素，并将它们打印到控制台上。程序员需要明确地指定循环的终止条件、每次迭代的操作等。这种方式比较适合处理简单的有序数据集合。</p>
</br>

<h3 id="反应性编程-1"><a href="#反应性编程-1" class="headerlink" title="反应性编程"></a>反应性编程</h3><p>&emsp;&emsp;而当使用反应性编程时，我们可以定义数据流和数据依赖关系，让数据的变化自动传播并触发相应的操作。例如以下JavaScript代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反应性编程示例</span></span><br><span class="line"><span class="keyword">const</span> source = <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>), <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">source.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Clicked!&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在上述代码中，我们使用RxJS库中的Observable类，通过fromEvent()方法来创建一个Observable对象，监听document中button元素的点击事件。当用户点击按钮时，Observable对象会发出一个事件，将其作为数据流自动传播到相关的组件，触发相应的操作（在这里，我们将“Clicked!”打印到控制台）。这种方式更加适合处理复杂的交互逻辑和需求实时响应的场景。</p>
</br>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">控制流程</label></li>
</ul>
<p>&emsp;&emsp;在命令式编程中，程序的控制流由程序员显式地指定，通过顺序执行代码来实现。而反应性编程中，控制流由数据流和事件驱动来决定，数据的变化会自动触发相应的操作。</p>
<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">数据流处理</label></li>
</ul>
<p>&emsp;&emsp;在命令式编程中，程序员需要编写显式的代码来处理数据的每一步操作，包括状态管理、循环等。而在反应性编程中，程序员通过定义数据流和数据依赖关系，数据的变化会自动传播到相关的组件。</p>
<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">异步处理</label></li>
</ul>
<p>&emsp;&emsp;反应性编程更加注重异步和事件驱动的处理方式，能够更好地应对实时性要求高、需要处理大量并发事件的场景。而命令式编程在处理异步操作时通常需要显式地使用回调函数或者使用线程等机制。</p>
<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">响应式思维</label></li>
</ul>
<p>&emsp;&emsp;反应性编程鼓励以数据流和事件为中心的思维方式，更加关注系统的响应性能力，能够更好地处理复杂的交互逻辑和实时数据的变化。</p>
</br>

<p>&emsp;&emsp;需要注意的是，命令式编程和反应性编程并不是完全独立的概念，它们可以在同一个应用中共存。例如，可以使用命令式编程语言编写应用的业务逻辑，同时使用反应性编程框架来处理事件驱动和异步操作。</p>
</br>

<p><img src="/../imgs/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF/%E5%9B%BA%E5%AE%9A%E5%BC%8F%E5%B8%83%E5%B1%80%E4%B8%8E%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80.png" alt="固定式布局与响应式布局"></p>
<h1 id="固定式布局与响应式布局"><a href="#固定式布局与响应式布局" class="headerlink" title="固定式布局与响应式布局"></a>固定式布局与响应式布局</h1><p>&emsp;&emsp;固定式布局（Fixed Layout）和响应式布局（Responsive Layout）是网页设计中常用的两种布局方式，它们在页面元素的排列和适应不同屏幕尺寸的方式上有所不同。</p>
</br>

<h2 id="固定式布局"><a href="#固定式布局" class="headerlink" title="固定式布局"></a>固定式布局</h2><ul>
<li>固定式布局是指在设计网页时，使用固定的像素单位来定义页面元素的尺寸和位置。</li>
<li>页面元素的尺寸、宽度、高度等都使用具体的像素值进行定义，不随浏览器窗口或设备屏幕尺寸的改变而自适应调整。</li>
<li>当用户在不同屏幕尺寸的设备上访问网页时，如果网页使用固定式布局，可能会导致页面内容无法完全显示或者需要通过滚动条进行查看。</li>
</ul>
</br>

<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><ul>
<li>响应式布局是指在设计网页时，使用相对单位（如百分比、em、rem等）以及媒体查询（media queries）来定义页面元素的尺寸和位置。</li>
<li>页面元素的宽度、高度等使用相对单位进行定义，使得它们能够根据浏览器窗口或设备屏幕的尺寸发生变化而自动调整大小。</li>
<li>通过使用媒体查询，可以针对不同的屏幕尺寸应用不同的样式和布局，以提供更好的用户体验。</li>
<li>响应式布局可以使网页在不同的设备上显示良好，无需用户手动调整或使用滚动条。</li>
</ul>
</br>

<h2 id="区别-3"><a href="#区别-3" class="headerlink" title="区别"></a>区别</h2><ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">适应性</label></li>
</ul>
<p>&emsp;&emsp;固定式布局不具备适应不同屏幕尺寸的能力，而响应式布局可以根据屏幕尺寸自动调整。</p>
<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">单位</label></li>
</ul>
<p>&emsp;&emsp;固定式布局使用像素单位进行定义，而响应式布局使用相对单位进行定义。</p>
<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">灵活性</label></li>
</ul>
<p>&emsp;&emsp;固定式布局的尺寸是固定的，无法灵活调整；响应式布局具有灵活性，可以根据屏幕尺寸变化进行适应。</p>
<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">用户体验</label></li>
</ul>
<p>&emsp;&emsp;固定式布局可能导致内容在某些设备上被裁剪或需要使用滚动条浏览，而响应式布局可以提供更好的用户体验，使内容在不同设备上自然适应。</p>
</br>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;当一个网页使用固定式布局时，网页中的各个元素（如导航栏、图片、文本块等）都是用像素单位进行定义，例如，导航栏的宽度为1000像素，内容区域的宽度为960像素，在大屏幕上显示良好，但如果用户在小屏幕（如手机屏幕）上访问此页面，可能需要使用水平滚动条才能查看所有内容，用户体验不佳。</p>
<p>&emsp;&emsp;相反，当一个网页使用响应式布局时，可以根据不同的屏幕尺寸提供不同的样式和布局。例如，在大屏幕上，导航栏可以水平排列，而在小屏幕上，导航栏可以折叠到一个菜单按钮中，使得页面更易于浏览。</p>
<p>&emsp;&emsp;另外，在响应式布局中，可以使用相对单位（如百分比、em、rem等）来定义元素的大小和位置，例如，可以使用<code>width: 100%</code>指定一个元素的宽度，使其充满整个容器。这样，当容器的大小变化时，元素也会自动调整大小，以适应其父容器的尺寸。</p>
</br>

<p><img src="/../imgs/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF/%E9%97%AD%E5%8C%85.png" alt="闭包"></p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;在前端开发中，闭包（Closure）是指函数和它所引用的外部变量的组合。闭包通过将函数内部的变量和作用域链保存起来，使得函数能够访问和操作外部的变量，即使在函数被调用后外部变量的作用域已经结束。当一个函数内部定义了另一个函数，并且内部函数引用了外部函数的变量时，就形成了闭包。具体来说，闭包是由以下两个要素组成：</p>
</br>

<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">函数</label></li>
</ul>
<p>&emsp;&emsp;在闭包中，通常有一个具名或匿名函数定义。</p>
<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">闭包环境</label></li>
</ul>
<p>&emsp;&emsp;函数内部引用的外部变量形成了闭包的环境，这些外部变量包括函数声明时所在的作用域内的变量、函数参数或任何外部函数的变量。</p>
</br>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">变量保留</label></li>
</ul>
<p>&emsp;&emsp;闭包使得函数可以保留对定义时作用域内变量的引用，即使这些变量在函数调用后已经离开了作用域，也不会被垃圾回收机制回收。</p>
<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">访问外部变量</label></li>
</ul>
<p>&emsp;&emsp;闭包允许函数访问和操作其外部作用域中的变量，即使函数被调用时外部作用域已经销毁。</p>
<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">延长生命周期</label></li>
</ul>
<p>&emsp;&emsp;由于闭包保留了外部变量的引用，因此这些变量的生命周期可能会比平常情况更长，可能会导致内存占用过多的问题。</p>
</br>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">封装私有变量和方法</label></li>
</ul>
<p>&emsp;&emsp;通过闭包，可以实现模块化开发，将一些私有信息隐藏起来，同时提供公共接口进行访问。</p>
<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">缓存数据</label></li>
</ul>
<p>&emsp;&emsp;利用闭包可以在函数外部缓存数据，避免重复计算的开销。</p>
<ul>
<li><label style="color:#49B1F5;background-color:#F8F8F8;border-radius:3px;padding:5px">保持状态</label></li>
</ul>
<p>&emsp;&emsp;闭包可以用来保存函数的状态，在异步操作中保持某些值的稳定性。</p>
</br>

<p>&emsp;&emsp;需要注意的是，闭包的不当使用可能会导致内存泄漏问题，因为被引用的外部变量无法被垃圾回收。因此，在使用闭包时需要注意合理管理内存，并避免创建不必要的闭包。</p>
</br>

<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> outerVariable = <span class="string">&#x27;I am outside!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(outerVariable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> innerFunction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> closure = <span class="title function_">outerFunction</span>(); <span class="comment">// 调用outerFunction并将返回的innerFunction赋值给变量closure</span></span><br><span class="line"><span class="title function_">closure</span>(); <span class="comment">// 输出: I am outside!</span></span><br></pre></td></tr></table></figure>

</br>

<p>&emsp;&emsp;在这个例子中，<code>outerFunction</code> 是外部函数，它定义了一个变量 <code>outerVariable</code> 和一个内部函数 <code>innerFunction</code>。内部函数 <code>innerFunction</code> 引用了外部函数 <code>outerFunction</code> 的变量 <code>outerVariable</code>。当我们调用 <code>outerFunction</code> 并将其返回的 <code>innerFunction</code> 存储在变量 <code>closure</code> 中时，<code>innerFunction</code> 成为了一个闭包，它保留了对外部函数变量 <code>outerVariable</code> 的引用。</p>
</br>

<p>&emsp;&emsp;随后，我们通过调用 <code>closure()</code> 执行了闭包 <code>innerFunction</code>，它打印出了保留的外部变量 <code>outerVariable</code> 的值 “I am outside!”。</p>
</br>

<p>&emsp;&emsp;这个例子展示了闭包的基本概念。<code>innerFunction</code> 在函数定义时捕获了外部作用域中的变量 <code>outerVariable</code>，即使 <code>outerFunction</code> 已经执行结束，但闭包 <code>innerFunction</code> 仍然可以访问和使用 <code>outerVariable</code> 的值。这种能力使得闭包在许多情况下很有用，比如封装私有变量和创建特定状态的函数等。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://l-204.github.io">lhr</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://l-204.github.io/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF/934f1248.html">https://l-204.github.io/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF/934f1248.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://l-204.github.io" target="_blank">自习室</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post_share"><div class="social-share" data-image="/../imgs/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF/background.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/328cf7b2.html" title="前端性能优化"><img class="cover" src="/../imgs/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/background.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端性能优化</div></div></a></div><div class="next-post pull-right"><a href="/%E4%BA%91%E9%9F%B3%E4%B9%90%E5%B0%8F%E7%A8%8B%E5%BA%8F/9809d611.html" title="云音乐小程序"><img class="cover" src="/../imgs/%E4%BA%91%E9%9F%B3%E4%B9%90%E5%B0%8F%E7%A8%8B%E5%BA%8F/background.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">云音乐小程序</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AB%9E%E8%B5%9B/3e2ff045.html" title="前端开发竞赛"><img class="cover" src="/../imgs/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AB%9E%E8%B5%9B/background.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-27</div><div class="title">前端开发竞赛</div></div></a></div><div><a href="/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/328cf7b2.html" title="前端性能优化"><img class="cover" src="/../imgs/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/background.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-16</div><div class="title">前端性能优化</div></div></a></div><div><a href="/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA/d2dc41b0.html" title="前端技术社区"><img class="cover" src="/../imgs/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA/background.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-27</div><div class="title">前端技术社区</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lhr</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/l-204"><i class="fab fa-github"></i><span>关注我的github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/l-204" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1248062965@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">跨过星河迈过月亮, 去迎接更好的自己!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">1.</span> <span class="toc-text">异步与同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">常见的异步操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1"><span class="toc-number">2.</span> <span class="toc-text">回调函数与回调地狱</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1"><span class="toc-number">2.2.</span> <span class="toc-text">回调地狱</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%8F%92%E5%80%BC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">解构赋值与插值语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">3.1.</span> <span class="toc-text">解构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">插值语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-1"><span class="toc-number">3.3.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%8F%8D%E5%BA%94%E6%80%A7%E7%BC%96%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">命令式编程与反应性编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">命令式编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%BA%94%E6%80%A7%E7%BC%96%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">反应性编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-2"><span class="toc-number">4.3.</span> <span class="toc-text">区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B-1"><span class="toc-number">4.3.1.</span> <span class="toc-text">命令式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%94%E6%80%A7%E7%BC%96%E7%A8%8B-1"><span class="toc-number">4.3.2.</span> <span class="toc-text">反应性编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">4.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%BC%8F%E5%B8%83%E5%B1%80%E4%B8%8E%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80"><span class="toc-number">5.</span> <span class="toc-text">固定式布局与响应式布局</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%BC%8F%E5%B8%83%E5%B1%80"><span class="toc-number">5.1.</span> <span class="toc-text">固定式布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80"><span class="toc-number">5.2.</span> <span class="toc-text">响应式布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-3"><span class="toc-number">5.3.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">5.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">6.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">6.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">6.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.3.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.4.</span> <span class="toc-text">代码示例</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AB%9E%E8%B5%9B/3e2ff045.html" title="前端开发竞赛"><img src="/../imgs/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AB%9E%E8%B5%9B/background.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端开发竞赛"/></a><div class="content"><a class="title" href="/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%AB%9E%E8%B5%9B/3e2ff045.html" title="前端开发竞赛">前端开发竞赛</a><time datetime="2023-10-27T14:27:37.000Z" title="发表于 2023-10-27 22:27:37">2023-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA/d2dc41b0.html" title="前端技术社区"><img src="/../imgs/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA/background.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端技术社区"/></a><div class="content"><a class="title" href="/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA/d2dc41b0.html" title="前端技术社区">前端技术社区</a><time datetime="2023-10-27T11:20:25.000Z" title="发表于 2023-10-27 19:20:25">2023-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/79666db.html" title="数据结构"><img src="/../imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/background.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构"/></a><div class="content"><a class="title" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/79666db.html" title="数据结构">数据结构</a><time datetime="2023-10-27T05:10:32.000Z" title="发表于 2023-10-27 13:10:32">2023-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/8e12165d.html" title="时间复杂度和空间复杂度"><img src="/../imgs/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/background.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="时间复杂度和空间复杂度"/></a><div class="content"><a class="title" href="/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/8e12165d.html" title="时间复杂度和空间复杂度">时间复杂度和空间复杂度</a><time datetime="2023-10-27T02:38:32.000Z" title="发表于 2023-10-27 10:38:32">2023-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%9F%B9%E6%A0%B9%E6%97%A5%E8%AE%B0/40f94b33.html" title="培根日记"><img src="/../imgs/%E5%9F%B9%E6%A0%B9%E6%97%A5%E8%AE%B0/background.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="培根日记"/></a><div class="content"><a class="title" href="/%E5%9F%B9%E6%A0%B9%E6%97%A5%E8%AE%B0/40f94b33.html" title="培根日记">培根日记</a><time datetime="2023-10-24T00:43:39.000Z" title="发表于 2023-10-24 08:43:39">2023-10-24</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/../imgs/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF/background.png')"><div id="footer-wrap"><div class="copyright">&copy;2023 By lhr</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>